<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Art</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    <script>
      let canvas = document.getElementById("myCanvas");
      function resizeCanvas() {
        const size = Math.min(window.innerWidth, window.innerHeight);
        canvas.width = size;
        canvas.height = size;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      let ctx;
      let PTS,
        ptsMin = 10,
        ptsMax = 40;
      let BG_COL;
      let cols, rows;
      let nodes = [];
      const COLORS = [["#F0E68C", "#ADD8E6", "#FFDAB9", "#DDA0DD", "#FFF0F5"]];

      class Vector {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      class Ball {
        constructor(x, y, colorI) {
          this.location = new Vector(x, y);
          this.cellSize = Math.floor(map(PTS, ptsMin, ptsMax, window.innerWidth / 32, window.innerWidth / 56));
          this.color = thisPalette[(colorI + Math.ceil(Math.random() * 10)) % thisPalette.length];
        }

        display() {
          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;
          ctx.fillStyle = this.color;
          ctx.fillRect(this.location.x - this.cellSize / 2, this.location.y - this.cellSize / 2, this.cellSize, this.cellSize);
          ctx.strokeRect(this.location.x - this.cellSize / 2, this.location.y - this.cellSize / 2, this.cellSize, this.cellSize);
        }
      }

      function map(value, start1, stop1, start2, stop2) {
        return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
      }

      function setup() {
        ctx = canvas.getContext("2d");

        PTS = Math.floor(Math.random() * (ptsMax - ptsMin + 1)) + ptsMin;
        let colsMin = Math.floor(map(PTS, 10, 40, 2, 5));
        cols = colsMin + Math.floor(Math.random() * (9 - colsMin));
        thisPalette = COLORS[Math.floor(Math.random() * COLORS.length)];
        BG_COL = thisPalette[Math.floor(Math.random() * thisPalette.length)];

        colsMin = Math.floor(map(PTS, 10, 40, 1, 5));
        console.log("colsMin", colsMin);
        cols = colsMin + Math.floor(Math.random() * 3) + 1;
        console.log("cols", cols);

        let ptsTemp = PTS;
        for (let i = 0; i < cols; i++) {
          let colsTemp = cols - i;
          let ptsRowMin = ((ptsTemp / colsTemp) * 1) / Math.max(colsTemp, 2);
          let ptsRowMax = (ptsTemp / colsTemp) * (1 + 1 / Math.max(colsTemp, 2));
          let ptsRow = i !== cols - 1 ? Math.floor(Math.random() * (ptsRowMax - ptsRowMin + 0)) + ptsRowMin : ptsTemp;

          let posX = canvas.width / (cols + 1);
          nodes[i] = [];
          for (let j = 0; j < ptsRow; j++) {
            let posY = canvas.width / (ptsRow + 1);
            nodes[i][j] = new Ball(posX * (i + 1), posY * (j + 1), i);
          }
          ptsTemp -= ptsRow;
        }
      }

      function draw() {
        ctx.fillStyle = BG_COL;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < nodes.length - 1; i++) {
          for (let j = 0; j < nodes[i].length; j++) {
            for (let k = 0; k < nodes[i + 1].length; k++) {
              ctx.beginPath();
              ctx.moveTo(nodes[i][j].location.x, nodes[i][j].location.y);
              ctx.lineTo(nodes[i + 1][k].location.x, nodes[i + 1][k].location.y);
              ctx.strokeStyle = "black";
              ctx.lineWidth = 0.5;
              ctx.stroke();
            }
          }
        }

        for (let i = 0; i < nodes.length; i++) {
          for (let j = 0; j < nodes[i].length; j++) {
            nodes[i][j].display();
          }
        }
      }

      // Call setup and draw
      setup();
      draw();
    </script>
  </body>
</html>
